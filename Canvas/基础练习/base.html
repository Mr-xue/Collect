<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas æ–‡å­—ç»˜åˆ¶å™¨ - Playful Geometric</title>
    <link rel="stylesheet" href="design-tokens.css">
</head>
<body class="dot-grid-bg">
    <!-- Decorative Shapes -->
    <div class="deco-circle deco-circle-yellow" style="width: 120px; height: 120px; top: -40px; left: -40px;"></div>
    <div class="deco-circle deco-circle-pink" style="width: 80px; height: 80px; top: 100px; right: -20px;"></div>
    <div class="deco-triangle deco-triangle-accent" style="width: 60px; height: 60px; bottom: 50px; left: 20px;"></div>

    <div class="canvas-container">
        <div class="canvas-wrapper">
            <canvas id="myCanvas"></canvas>
        </div>

        <div class="controls-panel">
            <h2>ğŸ¨ ç»˜åˆ¶è®¾ç½®</h2>

            <div class="form-group">
                <label class="form-label" for="textContent">æ–‡å­—å†…å®¹</label>
                <textarea id="textContent" class="form-textarea">Hello High-DPI Canvas!</textarea>
            </div>

            <div class="form-group">
                <label class="form-label" for="fontSize">
                    å­—ä½“å¤§å°: <span id="fontSizeValue" class="value-display">32</span>px
                </label>
                <input type="range" id="fontSize" class="form-range" min="12" max="72" value="32">
            </div>

            <div class="form-group">
                <label class="form-label" for="textColor">æ–‡å­—é¢œè‰²</label>
                <input type="color" id="textColor" class="form-color" value="#1E293B">
            </div>

            <div class="form-group">
                <label class="form-label">æ ·å¼é€‰é¡¹</label>
                <div class="form-checkbox-group">
                    <label class="form-checkbox-label">
                        <input type="checkbox" id="italic" class="form-checkbox">
                        <span>æ–œä½“</span>
                    </label>
                    <label class="form-checkbox-label">
                        <input type="checkbox" id="underline" class="form-checkbox">
                        <span>ä¸‹åˆ’çº¿</span>
                    </label>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label" for="letterSpacing">
                    å­—é—´è·: <span id="letterSpacingValue" class="value-display">0</span>px
                </label>
                <input type="range" id="letterSpacing" class="form-range" min="-5" max="20" value="0">
            </div>

            <div class="form-group">
                <label class="form-label" for="lineHeight">
                    è¡Œé—´è·: <span id="lineHeightValue" class="value-display">1.5</span>
                </label>
                <input type="range" id="lineHeight" class="form-range" min="1" max="3" step="0.1" value="1.5">
            </div>

            <div class="form-group">
                <label class="form-label" for="textAlign">å¯¹é½æ–¹å¼</label>
                <select id="textAlign" class="form-select">
                    <option value="left">å·¦å¯¹é½</option>
                    <option value="center" selected>å±…ä¸­</option>
                    <option value="right">å³å¯¹é½</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label" for="drawMode">ç»˜åˆ¶æ¨¡å¼</label>
                <select id="drawMode" class="form-select">
                    <option value="straight" selected>ç›´çº¿</option>
                    <option value="arc">åœ†å¼§</option>
                    <option value="sine">æ­£å¼¦æ›²çº¿</option>
                    <option value="cosine">ä½™å¼¦æ›²çº¿</option>
                </select>
            </div>

            <div class="form-group" id="amplitudeGroup" style="display: none;">
                <label class="form-label" for="amplitude">
                    æ›²çº¿å¹…åº¦: <span id="amplitudeValue" class="value-display">50</span>px
                </label>
                <input type="range" id="amplitude" class="form-range" min="10" max="150" value="50">
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');

        // è®¾ç½®canvasçš„CSSå°ºå¯¸
        const width = 600;
        const height = 600;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';

        // è·å–è®¾å¤‡åƒç´ æ¯”ï¼Œå®ç°é«˜æ¸…æ˜¾ç¤º
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;

        // ç¼©æ”¾ä¸Šä¸‹æ–‡ï¼Œä½¿ç»˜åˆ¶æ“ä½œä½¿ç”¨é€»è¾‘åƒç´ 
        ctx.scale(dpr, dpr);

        // è·å–æ§ä»¶å…ƒç´ 
        const textContent = document.getElementById('textContent');
        const fontSize = document.getElementById('fontSize');
        const fontSizeValue = document.getElementById('fontSizeValue');
        const textColor = document.getElementById('textColor');
        const italic = document.getElementById('italic');
        const underline = document.getElementById('underline');
        const letterSpacing = document.getElementById('letterSpacing');
        const letterSpacingValue = document.getElementById('letterSpacingValue');
        const lineHeight = document.getElementById('lineHeight');
        const lineHeightValue = document.getElementById('lineHeightValue');
        const textAlign = document.getElementById('textAlign');
        const drawMode = document.getElementById('drawMode');
        const amplitude = document.getElementById('amplitude');
        const amplitudeValue = document.getElementById('amplitudeValue');
        const amplitudeGroup = document.getElementById('amplitudeGroup');

        // è·å–æ–‡å­—æ ·å¼çš„é€šç”¨é…ç½®
        function getTextStyle() {
            const size = parseInt(fontSize.value);
            const color = textColor.value;
            const isItalic = italic.checked;
            const spacing = parseInt(letterSpacing.value);
            const fontStyle = isItalic ? 'italic' : 'normal';

            return { size, color, fontStyle, spacing };
        }

        // è®¾ç½®ä¸Šä¸‹æ–‡æ ·å¼
        function setContextStyles(style) {
            ctx.font = `${style.fontStyle} ${style.size}px sans-serif`;
            ctx.fillStyle = style.color;
            ctx.textBaseline = 'middle';
            ctx.letterSpacing = style.spacing + 'px';
        }

        // è®¡ç®—å•ä¸ªå­—ç¬¦çš„å®½åº¦ï¼ˆè€ƒè™‘å­—é—´è·ï¼‰
        function getCharWidth(char, size, spacing) {
            ctx.font = `${size}px sans-serif`;
            return ctx.measureText(char).width + spacing;
        }

        // è®¡ç®—æ•´ä¸ªæ–‡æœ¬çš„æ€»å®½åº¦
        function getTotalTextWidth(text, size, spacing) {
            let totalWidth = 0;
            for (let i = 0; i < text.length; i++) {
                totalWidth += getCharWidth(text[i], size, spacing);
            }
            return totalWidth - spacing;
        }

        // ç»˜åˆ¶ä¸‹åˆ’çº¿
        function drawUnderline(path, color) {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke(path);
            ctx.restore();
        }

        // ç›´çº¿ç»˜åˆ¶æ–¹æ³•
        function drawStraightText(text, style) {
            const { size, color, spacing } = style;
            const lineH = parseFloat(lineHeight.value);
            const align = textAlign.value;

            setContextStyles(style);
            ctx.textAlign = align;

            const lines = text.split('\n');
            const totalLines = lines.length;
            const lineHeightPx = size * lineH;
            const totalHeight = totalLines * lineHeightPx;
            const startY = (height - totalHeight) / 2 + lineHeightPx / 2;

            lines.forEach((line, index) => {
                const y = startY + index * lineHeightPx;
                let x;
                if (align === 'left') x = 5;
                else if (align === 'right') x = width - 5;
                else x = width / 2;

                // ç»˜åˆ¶ä¸‹åˆ’çº¿
                if (underline.checked) {
                    const totalWidth = getTotalTextWidth(line, size, spacing);
                    const underlineY = y + size / 2 + 4;
                    let underlineX;
                    if (align === 'left') underlineX = x;
                    else if (align === 'right') underlineX = x - totalWidth;
                    else underlineX = x - totalWidth / 2;

                    const underlinePath = new Path2D();
                    underlinePath.moveTo(underlineX, underlineY);
                    underlinePath.lineTo(underlineX + totalWidth, underlineY);
                    drawUnderline(underlinePath, color);
                }

                ctx.fillText(line, x, y);
            });
        }

        // åœ†å¼§ç»˜åˆ¶æ–¹æ³•
        function drawArcText(text, style) {
            const { size, color, spacing } = style;
            const amp = parseInt(amplitude.value);
            const lineH = parseFloat(lineHeight.value);

            setContextStyles(style);
            ctx.textAlign = 'center';

            const radius = amp;
            const centerX = width / 2;
            const centerY = height / 2 + radius * 0.3;

            // æŒ‰æ¢è¡Œç¬¦åˆ†å‰²æ–‡å­—
            const lines = text.split('\n');
            const totalLines = lines.length;
            const lineHeightPx = size * lineH;

            // è®¡ç®—æ‰€æœ‰è¡Œçš„æ€»é«˜åº¦ï¼Œç”¨äºå‚ç›´å±…ä¸­
            const totalHeight = totalLines * lineHeightPx;
            const startY = (height - totalHeight) / 2;

            // è®°å½•ä¸‹åˆ’çº¿è·¯å¾„
            let underlinePath = null;
            if (underline.checked) {
                underlinePath = new Path2D();
            }

            let isFirstPoint = true;

            // ç»˜åˆ¶æ¯ä¸€è¡Œ
            lines.forEach((line, lineIndex) => {
                const lineCenterY = startY + lineIndex * lineHeightPx + lineHeightPx / 2;

                // è°ƒæ•´åœ†å¿ƒï¼Œä½¿æ¯è¡Œæ–‡å­—å±…ä¸­
                const adjustedCenterY = centerY + (lineIndex - (totalLines - 1) / 2) * lineHeightPx;

                // è®¡ç®—æ–‡æœ¬æ€»å®½åº¦å¯¹åº”çš„å¼§åº¦
                const totalWidth = getTotalTextWidth(line, size, spacing);
                const totalAngle = totalWidth / radius;
                const startAngle = -totalAngle / 2;

                let currentAngle = startAngle;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const x = centerX + Math.cos(currentAngle) * radius;
                    const y = adjustedCenterY + Math.sin(currentAngle) * radius;

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(currentAngle + Math.PI / 2);
                    ctx.fillText(char, 0, 0);
                    ctx.restore();

                    // ä¸‹åˆ’çº¿
                    if (underline.checked) {
                        const charWidth = getCharWidth(char, size, spacing);
                        // æ–‡å­—æœå¤–æ—‹è½¬ï¼ˆcurrentAngle + Math.PI/2ï¼‰ï¼Œæ‰€ä»¥ä¸‹åˆ’çº¿åº”åœ¨æ–‡å­—å†…ä¾§ï¼ˆå‘åœ†å¿ƒæ–¹å‘ï¼‰
                        const underlineRadius = radius - size / 2 - 4;

                        // ä½¿ç”¨å¤šä¸ªé‡‡æ ·ç‚¹ä½¿ä¸‹åˆ’çº¿æ›´å¹³æ»‘è¿è´¯
                        const samples = 10;
                        for (let s = 0; s < samples; s++) {
                            const t1 = s / samples;
                            const t2 = (s + 1) / samples;
                            const angle1 = currentAngle + t1 * charWidth / radius;
                            const angle2 = currentAngle + t2 * charWidth / radius;

                            const x1 = centerX + Math.cos(angle1) * underlineRadius;
                            const y1 = adjustedCenterY + Math.sin(angle1) * underlineRadius;
                            const x2 = centerX + Math.cos(angle2) * underlineRadius;
                            const y2 = adjustedCenterY + Math.sin(angle2) * underlineRadius;

                            if (isFirstPoint) {
                                underlinePath.moveTo(x1, y1);
                                isFirstPoint = false;
                            } else {
                                underlinePath.lineTo(x1, y1);
                            }
                            underlinePath.lineTo(x2, y2);
                        }
                    }

                    currentAngle += getCharWidth(char, size, spacing) / radius;
                }
            });

            if (underline.checked) {
                drawUnderline(underlinePath, color);
            }
        }

        // æ­£å¼¦æ›²çº¿ç»˜åˆ¶æ–¹æ³•
        function drawSineText(text, style) {
            drawWaveText(text, style, 'sine');
        }

        // ä½™å¼¦æ›²çº¿ç»˜åˆ¶æ–¹æ³•
        function drawCosineText(text, style) {
            drawWaveText(text, style, 'cosine');
        }

        // æ³¢æµªæ›²çº¿ç»˜åˆ¶é€šç”¨æ–¹æ³•
        function drawWaveText(text, style, waveType) {
            const { size, color, spacing } = style;
            const amp = parseInt(amplitude.value);
            const lineH = parseFloat(lineHeight.value);

            setContextStyles(style);
            ctx.textAlign = 'center';

            // æŒ‰æ¢è¡Œç¬¦åˆ†å‰²æ–‡å­—
            const lines = text.split('\n');
            const totalLines = lines.length;
            const lineHeightPx = size * lineH;

            // è®¡ç®—æ‰€æœ‰è¡Œçš„æ€»é«˜åº¦ï¼Œç”¨äºå‚ç›´å±…ä¸­
            const totalHeight = totalLines * lineHeightPx;
            const startY = (height - totalHeight) / 2;

            let underlinePath = null;
            if (underline.checked) {
                underlinePath = new Path2D();
            }

            let isFirstPoint = true;

            // ç»˜åˆ¶æ¯ä¸€è¡Œ
            lines.forEach((line, lineIndex) => {
                const lineCenterY = startY + lineIndex * lineHeightPx + lineHeightPx / 2;

                const totalWidth = getTotalTextWidth(line, size, spacing);
                const startX = (width - totalWidth) / 2;

                let currentX = startX;
                const waveLength = totalWidth;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const charWidth = getCharWidth(char, size, spacing);
                    const midX = currentX + charWidth / 2;
                    const progress = (midX - startX) / waveLength;

                    let y, rotation;
                    if (waveType === 'sine') {
                        y = lineCenterY + Math.sin(progress * Math.PI * 2) * amp;
                        // è®¡ç®—æ­£å¼¦æ›²çº¿çš„åˆ‡çº¿è§’åº¦ï¼šdy/dx = cos(2Ï€x/L) * 2Ï€ * amp / L
                        const derivative = Math.cos(progress * Math.PI * 2) * (Math.PI * 2) * amp / waveLength;
                        rotation = Math.atan(derivative);
                    } else {
                        y = lineCenterY + Math.cos(progress * Math.PI * 2) * amp;
                        // è®¡ç®—ä½™å¼¦æ›²çº¿çš„åˆ‡çº¿è§’åº¦ï¼šdy/dx = -sin(2Ï€x/L) * 2Ï€ * amp / L
                        const derivative = -Math.sin(progress * Math.PI * 2) * (Math.PI * 2) * amp / waveLength;
                        rotation = Math.atan(derivative);
                    }

                    ctx.save();
                    ctx.translate(midX, y);
                    ctx.rotate(rotation);
                    ctx.fillText(char, 0, 0);
                    ctx.restore();

                    // ä¸‹åˆ’çº¿
                    if (underline.checked) {
                        const underlineOffset = size / 2 + 4;
                        const samples = 10;

                        for (let s = 0; s < samples; s++) {
                            const t1 = s / samples;
                            const t2 = (s + 1) / samples;
                            const x1 = currentX + t1 * charWidth;
                            const x2 = currentX + t2 * charWidth;
                            const p1 = (x1 - startX) / waveLength;
                            const p2 = (x2 - startX) / waveLength;

                            let y1, y2;
                            if (waveType === 'sine') {
                                y1 = lineCenterY + Math.sin(p1 * Math.PI * 2) * amp + underlineOffset;
                                y2 = lineCenterY + Math.sin(p2 * Math.PI * 2) * amp + underlineOffset;
                            } else {
                                y1 = lineCenterY + Math.cos(p1 * Math.PI * 2) * amp + underlineOffset;
                                y2 = lineCenterY + Math.cos(p2 * Math.PI * 2) * amp + underlineOffset;
                            }

                            if (isFirstPoint) {
                                underlinePath.moveTo(x1, y1);
                                isFirstPoint = false;
                            } else {
                                underlinePath.lineTo(x1, y1);
                            }
                            underlinePath.lineTo(x2, y2);
                        }
                    }

                    currentX += charWidth;
                }
            });

            if (underline.checked) {
                drawUnderline(underlinePath, color);
            }
        }

        // ç»˜åˆ¶æ¨¡å¼è·¯ç”±å™¨
        const drawModeHandlers = {
            'straight': drawStraightText,
            'arc': drawArcText,
            'sine': drawSineText,
            'cosine': drawCosineText
        };

        // ä¸»ç»˜åˆ¶å‡½æ•°
        function drawText() {
            ctx.clearRect(0, 0, width, height);

            const text = textContent.value;
            const style = getTextStyle();
            const mode = drawMode.value;

            const handler = drawModeHandlers[mode];
            if (handler) {
                handler(text, style);
            }
        }

        // æ›´æ–°æ˜¾ç¤ºå€¼å¹¶é‡ç»˜
        function updateAndDraw() {
            fontSizeValue.textContent = fontSize.value;
            letterSpacingValue.textContent = letterSpacing.value;
            lineHeightValue.textContent = lineHeight.value;
            amplitudeValue.textContent = amplitude.value;
            drawText();
        }

        // åˆ‡æ¢å¹…åº¦æ§åˆ¶æ˜¾ç¤º
        function toggleAmplitudeControl() {
            const mode = drawMode.value;
            amplitudeGroup.style.display = mode === 'straight' ? 'none' : 'block';
        }

        // ä¸ºæ‰€æœ‰æ§ä»¶æ·»åŠ äº‹ä»¶ç›‘å¬
        textContent.addEventListener('input', drawText);
        fontSize.addEventListener('input', updateAndDraw);
        textColor.addEventListener('input', drawText);
        italic.addEventListener('change', drawText);
        underline.addEventListener('change', drawText);
        letterSpacing.addEventListener('input', updateAndDraw);
        lineHeight.addEventListener('input', updateAndDraw);
        textAlign.addEventListener('change', drawText);
        drawMode.addEventListener('change', () => {
            toggleAmplitudeControl();
            drawText();
        });
        amplitude.addEventListener('input', updateAndDraw);

        // åˆå§‹ç»˜åˆ¶
        toggleAmplitudeControl();
        drawText();
    </script>
</body>
</html>